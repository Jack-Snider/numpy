"""
넘파이 배열 생성하기
"""
# BEGINS
import numpy as np

l = [ 1,2,3,4 ]
a = np.array( l )
print( a )
print( f'type(a) : { type( a ) }' )

# 파이썬 튜플을 array함수에 전달해서 다차원 배열 만들기
t = ( 1,2,3,4 )
b = np.array( t )
print( b )
print( f'type(b) : { type( b ) }' )

"""
다차원 배열은 실제 데이터를 관리하는 속성과 이 데이터의 정보를 관리하는 메타속성을 구분해서 관리한다.
먼저 데이터를 관리하는 속성은 data을 조회하면 메모리에 저장된 레퍼런스를 출력한다.

이 데이터를 obj로 참조하면 다차원 배열의 값을 보여준다. 이 데이터의 자료형을 확인하면 다차원 배열이다.
"""
print( f'a.data : { a.data }' )
print( f'a.data.obj : { a.data.obj }' )

"""
다른 변수에 할당하면 다차원 배열을 관리하는 별칭( alias )가 더 만들어진다. 속성 base는
다차원 배열의 메모리를 공유할 때 원본 레퍼런스를 저장한다. 별칭을 사용하는 것은 동일한 다차원
배열을 공유하는 구조라서 base에는 아무것도 없다.
"""
c = b
print( f'c.base is b.base : { c.base is b.base }' )

"""
새로운 변수 c에 저장된 첫 번째 원소를 변경하면 내부에 저장된 원본 배열을 변경한다.
모든 변수를 조회하면 다차원 배열의 변경된 것을 볼 수 있다.
"""
c[ 0 ] = 100
print( f'c : { c }' )
print( f'b : { b }' )

"""
이번에는 다차원 배열을 복사해서 새로운 배열을 만든다. 다차원 배열의 객체를 array함수에 넣어서
다른 다차원 배열을 만들면 동일한 값을 가진 새로운 배열을 만든다.

이 내부에 있는 첫 번째 원소를 변경한다. 복사된 배열은 변경되지만 원본은 변경되지 않는다.
"""
d = np.array( b )
d[ 0 ] = 99
print( f'd : { d }' )
print( f'b : { b }' )

"""
배열은 하나의 자료형을 가진다고 했지만 앞에서는 다차원 배열을 만들 때는 자료형을 지정하지 않았다.
다차원 배열을 생성할 때 자료형을 지정하지 않으면 내부의 원소를 보고 자동으로 추론해서 만들어진다.

이번에는 array 함수의 dtype 매개변수에 특정 자료형은 float을 지정해서 다차원 배열을 만든다.
다차원 배열 내의 속성 dtype으로 내부에 만들어진 원소들의 대표 속성을 확인할 수 있다.
"""
e = np.array( 1, dtype = float )
print( f'e : { e }' )
print( f'e.dtype : { e.dtype }' )

"""
2차원 배열이라는 것은 행과 열 2개의 축을 가지는 배열을 말한다. 두 개의 1차원 배열인 벡터가 쌓여서
하나의 2차원 배열인 행렬이 만들어지는 것이다.

리스트 내에 리스트를 내포해서 array 함수에 전달해서 다차원 배열을 만든다. 이 다차원 배열은
2개의 축을 가진 2차원 배열이 만들어진다. 2차원 배열은 두 개의 축( axis )을 가진다.
행( row )을 표시하는 축과 열( column )을 표시하는 축으로 이루어져 있다. 이 두 개의
축의 원소의 개수는 다차원 배열의 shape 속성으로 조회한다. 두 개의 축을 가지므로
두 개의 원소를 가진 파이썬 튜플로 반환한다. 이 튜플에 첫 번째 원소는 행을 표시하고
두 번째 원소는 열을 표시한다. 또한 축의 개수는 ndim속성으로 조회한다. 결과가 2라는 것은
2차원이며 두 개의 축을 가졌다는 의미를 말한다.

배열은 하나의 클래스의 객체로만 구성된다. 이를 확인하려면 dtype 속성을 조회한다. 결과를
확인하면 dtype 클래스의 객체이고 원소의 자료형은 문자열 int32를 의마한다.
"""
a2 = np.array( [ [ 1,2,3 ], [ 4,5,6 ] ] )
print( f"a2.shape : { a2.shape }" )
print( f"a2.ndim : { a2.ndim }" )
print( f"a2.dtype : { a2.dtype }" )

print( f'a2.shape : { a2.shape }' )
print( f'a2.ndim : { a2.ndim }' )
print( f'a2.dtype : { a2.dtype }' )

"""
다차원 배열을 모든 원소는 동일한 길이로 구성된다. 자료가 저장될 때 바이트( byte ) 단위로 구성한다.
1 바이트( byte )는 8비트( bit )이다. 이 배열의 itemsize 속성을 조회하면 4이다.
이 뜻은 4바이트이고 비트로 계산하면 32이다. 위에서 int32라는 자료형이므로 하나의 원소는 정수 32비트로 구성된 원소라는 것을 알 수 있다.
모든 원소의 개수는 size 속성으로 확인이 가능하다. 이 배열의 형상인 shape 속성에 있는 튜플의 두 원소를 곱한 결과와 같다.
 
넘파이 모듈의 2차원 배열은 행을 기준으로 내부의 1차원 배열을 원소로 관리한다. 이 배열을 확장하려면 하나의 1차원 배열이 구성된
바이트를 알아야한다. 이 기준 정보를 관리하는 strides속성을 확인하면 두 개의 원소를 가진 튜플이다. 첫 번째 원소는 하나의 행의
원소가 3개이므로 4바이트로 곱해서 12이다. 두 번째 원소는 하나의 원소를 관리하는 바이트이다. 첫 번째는 하나의 행의 전체 길이를,
두 번째는 1차원 배열의 원소 하나의 길이를 알려준다. 이 배열을 확장할 때는 12 바이트 단위로 원소가 추가되는 것을 알 수 있다.  
"""

print( f'a2.itemszie : { a2.itemsize }' )
print( f'a2.size : { a2.size }' )
print( f'a2.strides : { a2.strides }' )

"""
다차원 배열은 데이터를 저장할 때 내부에서는 1차원으로 구성해서 관리한다. 위의 다차원 배열은
2차원 배열인 행렬을 만들었지만 내부의 데이터 관리는 1차원이다. 이 다차원 배열을 두 개의
flatten과 ravel 메소드를 사용해서 1차원 배열로 조회할 수 있다.
하지만 이 두 메소드를 실행하면 반환되는 결과가 다르다. 어떤 차이가 있는지 알아보자.

행렬을 flatten 메소드로 실행하고 그 다음에 ravel 메소드로 실행해서 동일한 1차원 배열을
출력한다. 두 메소드의 실행결과 중에 ravel 메소드는 내부 데이터를 그대로 반환하는 뷰( view )이다.
이는 원본 배열과 동일한 정보로 처리한다는 뜻이다. 그래서 원소를 변경하면 원본 배열의 원소도 같이 변경된다.

원소를 변경할 때는 flatten 메소드를 사용해서 다른 다차원 배열을 만들어서 사용하는 것이 좋다.
"""
print( f'a2.flatten : { a2.flatten() }' )
print( f'a2.ravel : { a2.ravel() }' )



